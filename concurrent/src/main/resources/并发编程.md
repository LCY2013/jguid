### 并发处理思路
分发、同步、互斥

### 发生死锁四个条件
1、互斥：存在竞争资源，只能被某一个线程持有

2、占有且等待：线程T1占有竞争资源R1，等待资源R2的同时不能够释放资源R1

3、不可抢占：线程T1占有资源R1的时候，其他线程不能够抢占资源R1

4、循环等待：存在线程T1占有T2需要的资源R1，线程T2占有T1需要的资源R2，就会发送循环等待

### 解决死锁问题
发生死锁的四个条件中，互斥是必然存在的所以需要从其他三个条件解决死锁问题

1、占有且等待：一次性申请所有的资源，就不存在等待

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/one)

2、不可抢占：线程在占有资源R1去申请资源R2，如果申请不到R2就释放R1资源

[不可抢占示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/two)

Java语言本身的元语synchronized不能够满足这点，因为加锁释放都是由JVM层控制实现，不过JUC提供了实现思路(Lock)。

3、循环等待：对锁资源进行资源排序，每次都按资源顺序大小排序进行上锁操作

[循环等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/three)

### 等待-通知机制

synchronized - wait - notify/notifyAll

疑问：为什么wait/notify机制必须要在synchronized语义中才能实现呢？
```text
首先需要理解synchronized元语在JVM层的实现，JVM维护了两个数组，等待队列、锁队列
锁队列需要做的事情：检测资源是否满足 -> 满足就进行竞争获取锁(MonitorEnter，monitor信息放在对象头中)，不满足就进入锁队列 -> 获取到锁资源的线程执行完成(MonitorExit)，去锁列队唤醒线程重新争抢锁资源
等待队列需要做的事情：拥有锁资源的线程在完成自己作业后主动放弃资源所有就会进入等待队列 -> 其他线程获取到资源完成自己作业后通知等待队列中的线程重新争抢锁资源进行作业

所以等待-通知 机制是等待队列和锁队列协同工作实现的
```

疑问：为什么wait/notify属于Object而不是Thread？
```text
wait/notify属于资源判断条件应该属于对象
```

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/waitnotify/one)

### 安全性问题、活跃性问题、性能问题

并发问题产生原因：原子性、可见性、有序性

安全性问题：按照我们期望的逻辑执行就是安全的，反之就是不安全的。

活跃性问题：指某个操作无法执行下去。例如：死锁、活锁、饥饿

性能问题：锁的粒度过大就存在性能问题，锁过度使用造成的串行也会造成性能问题。 
```
阿姆达尔(Amdahl)定律

S=1/(1-a+a/n)
其中，a为并行计算部分所占比例，n为并行处理结点个数(CPU核数)。
这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；
当a=0时（即只有串行，没有并行），最小加速比s=1；
当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。
例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。
```

性能衡量标准：吞吐量、延迟、并发量
```
吞吐量：单位时间内处理的请求数量，能处理的请求数量越高，性能越好

延迟：单次请求的响应时间越短，性能越好

并发量：同时处理请求的数量，同时请求的数量越大往往延迟就会越高，所以延迟这个指标和并发量是相关的
```

### 什么是管程？

不知道你是否曾思考过这个问题：为什么 Java 在 1.5 之前仅仅提供了 synchronized 关键字及 wait()、notify()、notifyAll() 这三个看似从天而降的方法？

操作系统原理讲用信号量能解决所有并发问题，但是Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。

管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程，但是管程更容易使用，所以 Java 选择了管程。

管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译，操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”，所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。

翻译为Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。

### 那管程是怎么管的呢？

MESA 模型在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。

其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是MESA 模型。

在并发编程领域，有两大核心问题：

一个是互斥，即同一时刻只允许一个线程访问共享资源；

一个是同步，即线程之间如何通信、协作。

管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来。

### wait() 的正确姿势

对于 MESA 管程来说，有一个编程范式，就是需要在一个while 循环里面调用 wait(),这个是 MESA 管程特有的：
```
while(条件未满足){
    wait();
}
```

Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。

管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行呢？ 
     
1. Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。

2. Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。

3. MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。

### notify() 何时可以使用

需要注意的地方，就是 notify() 和 notifyAll() 的使用，尽量使用 notifyAll()，那什么时候可以使用 notify() 呢？需要满足以下三个条件：

1. 所有等待线程拥有相同的等待条件；

2. 所有等待线程被唤醒后，执行相同的操作；

3. 只需要唤醒一个线程。












