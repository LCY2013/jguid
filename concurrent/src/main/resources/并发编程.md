# 并发处理思路
分发、同步、互斥

# 发生死锁四个条件
1、互斥：存在竞争资源，只能被某一个线程持有

2、占有且等待：线程T1占有竞争资源R1，等待资源R2的同时不能够释放资源R1

3、不可抢占：线程T1占有资源R1的时候，其他线程不能够抢占资源R1

4、循环等待：存在线程T1占有T2需要的资源R1，线程T2占有T1需要的资源R2，就会发送循环等待

# 解决死锁问题
发生死锁的四个条件中，互斥是必然存在的所以需要从其他三个条件解决死锁问题

1、占有且等待：一次性申请所有的资源，就不存在等待

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/one)

2、不可抢占：线程在占有资源R1去申请资源R2，如果申请不到R2就释放R1资源

[不可抢占示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/two)

Java语言本身的元语synchronized不能够满足这点，因为加锁释放都是由JVM层控制实现，不过JUC提供了实现思路(Lock)。

3、循环等待：对锁资源进行资源排序，每次都按资源顺序大小排序进行上锁操作

[循环等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/three)





