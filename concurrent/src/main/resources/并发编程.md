### 并发处理思路
分发、同步、互斥

### 发生死锁四个条件
1、互斥：存在竞争资源，只能被某一个线程持有

2、占有且等待：线程T1占有竞争资源R1，等待资源R2的同时不能够释放资源R1

3、不可抢占：线程T1占有资源R1的时候，其他线程不能够抢占资源R1

4、循环等待：存在线程T1占有T2需要的资源R1，线程T2占有T1需要的资源R2，就会发送循环等待

### 解决死锁问题
发生死锁的四个条件中，互斥是必然存在的所以需要从其他三个条件解决死锁问题

1、占有且等待：一次性申请所有的资源，就不存在等待

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/one)

2、不可抢占：线程在占有资源R1去申请资源R2，如果申请不到R2就释放R1资源

[不可抢占示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/two)

Java语言本身的元语synchronized不能够满足这点，因为加锁释放都是由JVM层控制实现，不过JUC提供了实现思路(Lock)。

3、循环等待：对锁资源进行资源排序，每次都按资源顺序大小排序进行上锁操作

[循环等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/three)

### 等待-通知机制

synchronized - wait - notify/notifyAll

疑问：为什么wait/notify机制必须要在synchronized语义中才能实现呢？
```text
首先需要理解synchronized元语在JVM层的实现，JVM维护了两个数组，等待队列、锁队列
锁队列需要做的事情：检测资源是否满足 -> 满足就进行竞争获取锁(MonitorEnter，monitor信息放在对象头中)，不满足就进入锁队列 -> 获取到锁资源的线程执行完成(MonitorExit)，去锁列队唤醒线程重新争抢锁资源
等待队列需要做的事情：拥有锁资源的线程在完成自己作业后主动放弃资源所有就会进入等待队列 -> 其他线程获取到资源完成自己作业后通知等待队列中的线程重新争抢锁资源进行作业

所以等待-通知 机制是等待队列和锁队列协同工作实现的
```

疑问：为什么wait/notify属于Object而不是Thread？
```text
wait/notify属于资源判断条件应该属于对象
```

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/waitnotify/one)

### 安全性问题、活跃性问题、性能问题

并发问题产生原因：原子性、可见性、有序性

安全性问题：按照我们期望的逻辑执行就是安全的，反之就是不安全的。

活跃性问题：指某个操作无法执行下去。例如：死锁、活锁、饥饿

性能问题：锁的粒度过大就存在性能问题，锁过度使用造成的串行也会造成性能问题。 
```
阿姆达尔(Amdahl)定律

S=1/(1-a+a/n)
其中，a为并行计算部分所占比例，n为并行处理结点个数(CPU核数)。
这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；
当a=0时（即只有串行，没有并行），最小加速比s=1；
当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。
例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。
```

性能衡量标准：吞吐量、延迟、并发量
```
吞吐量：单位时间内处理的请求数量，能处理的请求数量越高，性能越好

延迟：单次请求的响应时间越短，性能越好

并发量：同时处理请求的数量，同时请求的数量越大往往延迟就会越高，所以延迟这个指标和并发量是相关的
```













