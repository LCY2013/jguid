### 并发处理思路
分发、同步、互斥

### 发生死锁四个条件
1、互斥：存在竞争资源，只能被某一个线程持有

2、占有且等待：线程T1占有竞争资源R1，等待资源R2的同时不能够释放资源R1

3、不可抢占：线程T1占有资源R1的时候，其他线程不能够抢占资源R1

4、循环等待：存在线程T1占有T2需要的资源R1，线程T2占有T1需要的资源R2，就会发送循环等待

### 解决死锁问题
发生死锁的四个条件中，互斥是必然存在的所以需要从其他三个条件解决死锁问题

1、占有且等待：一次性申请所有的资源，就不存在等待

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/one)

2、不可抢占：线程在占有资源R1去申请资源R2，如果申请不到R2就释放R1资源

[不可抢占示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/two)

Java语言本身的元语synchronized不能够满足这点，因为加锁释放都是由JVM层控制实现，不过JUC提供了实现思路(Lock)。

3、循环等待：对锁资源进行资源排序，每次都按资源顺序大小排序进行上锁操作

[循环等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/deallock/dealwith/three)

### 等待-通知机制

synchronized - wait - notify/notifyAll

疑问：为什么wait/notify机制必须要在synchronized语义中才能实现呢？
```text
首先需要理解synchronized元语在JVM层的实现，JVM维护了两个数组，等待队列、锁队列
锁队列需要做的事情：检测资源是否满足 -> 满足就进行竞争获取锁(MonitorEnter，monitor信息放在对象头中)，不满足就进入锁队列 -> 获取到锁资源的线程执行完成(MonitorExit)，去锁列队唤醒线程重新争抢锁资源
等待队列需要做的事情：拥有锁资源的线程在完成自己作业后主动放弃资源所有就会进入等待队列 -> 其他线程获取到资源完成自己作业后通知等待队列中的线程重新争抢锁资源进行作业

所以等待-通知 机制是等待队列和锁队列协同工作实现的
```

疑问：为什么wait/notify属于Object而不是Thread？
```text
wait/notify属于资源判断条件应该属于对象
```

[占有且等待示例](https://github.com/LCY2013/jguid/tree/master/concurrent/src/main/java/org/fufeng/concurrent/cases/waitnotify/one)






