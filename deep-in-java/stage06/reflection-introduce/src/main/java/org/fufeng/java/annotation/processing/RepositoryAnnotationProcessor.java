/*
 * The MIT License (MIT)
 * ------------------------------------------------------------------
 * Copyright © 2019 Ramostear.All Rights Reserved.
 *
 * ProjectName: jguid
 * @Author : <a href="https://github.com/lcy2013">MagicLuo</a>
 * @date : 2020-07-31
 * @version : 1.0.0-RELEASE
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
package org.fufeng.java.annotation.processing;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Types;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

import static org.fufeng.java.annotation.processing.RepositoryAnnotationProcessor.REPOSITORY_ANNOTATION_CLASS_NAME;

/**
 * @program: jguid
 * @description: {@link Processor} 注解处理器
 * 1. 扩展 javax.annotation.processing.AbstractProcessor 抽象类
 * 2. 指定需要处理的注解类名（集合）
 * 3. 指定支持的 Java 源代码版本
 * 4. 指定支持的 Processor org.fufeng.java.reflection.Repository 参数 Options（可选）
 * 5. 利用 Java SPI 配置 javax.annotation.processing.Processor 的实现类
 * @author: <a href="https://github.com/lcy2013">MagicLuo(扶风)</a>
 * @create: 2020-07-31
 * @see Processor 注解处理器
 */
@SupportedAnnotationTypes(REPOSITORY_ANNOTATION_CLASS_NAME)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class RepositoryAnnotationProcessor extends AbstractProcessor {

    final static String REPOSITORY_ANNOTATION_CLASS_NAME = "org.fufeng.java.reflection.Repository";

    private final static String CURD_REPOSITORY_ANNOTATION_CLASS_NAME = "org.fufeng.java.reflection.CurdRepository";

    /**
     * key ->  为CurdRepository 接口实现类
     * value -> 为CurdRepository 接口第一个参数类型
     */
    private final Map<String, String> curdRepositoryParameterizedTypeMapping = new HashMap<>();

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // 输出处理的注解类名称
        // 第一阶段: 处理阶段
        // 获取所有的编译类
        roundEnv.getRootElements()
                .stream()
                .filter(this::isRepositoryAnnotationPresent) // 过滤标注 @org.fufeng.java.reflection.Repository 的元素
                .forEach(this::processRepositoryAnnotatedElement);     // 处理标注 @org.fufeng.java.reflection.Repository 的元素

        // 第二个阶段：完成阶段
        if (roundEnv.processingOver()) {
            // 将 crudRepositoryParameterizedTypesMapping 输出到新生成的文件
            try {
                generateCrudRepositoryParameterizedTypesMetadata();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return false;
    }

    private void generateCrudRepositoryParameterizedTypesMetadata() throws IOException {
        // 找到ClassPath
        Filer filter = processingEnv.getFiler();
        // 定义的配置文件位置
        String resourceName = "META-INF/curd-repos-mapping.properties";
        final FileObject fileObject =
                filter.createResource(StandardLocation.CLASS_OUTPUT, "", resourceName);
        try (final Writer writer = fileObject.openWriter()){
            Properties properties = new Properties();
            properties.putAll(curdRepositoryParameterizedTypeMapping);
            properties.store(writer,"Generated by RepositoryAnnotationProcessor");
        }
    }

    /**
     *  处理Repository标注的元素
     * @param element 元素
     */
    private void processRepositoryAnnotatedElement(Element element){
        if (!isConcreteClass(element) || !isCurdRepositoryType(element)){
            return;
        }
        System.out.println("CurdRepository 实现类为:"+element.toString());
        // CurdRepository接口类型
        final TypeMirror curdRepositoryGenericInterfaceType =
                getGenericInterfaceType(element, CURD_REPOSITORY_ANNOTATION_CLASS_NAME);
        System.out.println("CurdRepository 实现泛型接口定义为:"+curdRepositoryGenericInterfaceType);
        // 由于CurdRepository 是接口类型,可以强制转换为DeclaredType
        final DeclaredType declaredType =
                (DeclaredType) curdRepositoryGenericInterfaceType;
        // 获取泛型参数类型列表
        assert declaredType != null;
        final List<? extends TypeMirror> typeArguments =
                declaredType.getTypeArguments();
        // 获取第一个参数类型
        final TypeMirror firstTypeMirror = typeArguments.get(0);
        // 查询出来的对象信息
        System.out.println("CurdRepository 实现接口的首个泛型参数为:"+firstTypeMirror);
        /*
         * key ->  为CurdRepository 接口实现类
         * value -> 为CurdRepository 接口第一个参数类型
         */
        this.curdRepositoryParameterizedTypeMapping.put(curdRepositoryGenericInterfaceType.toString(),firstTypeMirror.toString());
    }

    /**
     *  判断元素是否是具体类
     * @param element 元素
     * @return 是否是具体类
     */
    private boolean isConcreteClass(Element element){
        return !element.getModifiers().contains(Modifier.ABSTRACT);
    }

    /**
     *  判断某个元素是不是CurdRepository类型
     * @param element 元素
     * @return 是否是CurdRepository 类型
     */
    private boolean isCurdRepositoryType(Element element){
        return Objects.nonNull(getGenericInterfaceType(element,CURD_REPOSITORY_ANNOTATION_CLASS_NAME));
    }

    /**
     *  获取接口类型的泛型信息
     * @param element 元素
     * @param interfaceTypeName 接口类型名称
     * @return 类型
     */
    private TypeMirror getGenericInterfaceType(Element element,
                                               String interfaceTypeName) {
        final ElementKind elementKind = element.getKind();
        if (elementKind.isClass() && element instanceof TypeElement){
            TypeElement typeElement = (TypeElement) element;
            return typeElement.getInterfaces().stream() // 查询当前参数类型的所有接口
                    .filter(interfaceType -> typeEquals(interfaceType,interfaceTypeName))
                    .findFirst() // 找到第一个符合条件的CurdRepository接口
                    .orElse(null);
        }
        return null;
    }

    /**
     * 类型是否一致判断
     *
     * @param typeMirror 类型
     * @param typeName   类型名称
     * @return 是否一致
     */
    private boolean typeEquals(TypeMirror typeMirror, String typeName) {
        // 通过处理环境获取类型工具类
        final Types types = processingEnv.getTypeUtils();
        // 擦写泛型参数
        final TypeMirror mirror = types.erasure(typeMirror);
        return Objects.equals(typeName, mirror.toString());
    }

    /**
     * 注解元素是否存在注解
     *
     * @param element 元素
     * @return 是否存在注解标注
     */
    private boolean isRepositoryAnnotationPresent(Element element) {
        return isAnnotationPresent(element, REPOSITORY_ANNOTATION_CLASS_NAME);
    }

    /**
     * 是不是指定的注解标注的类型
     *
     * @param element             元素
     * @param annotationClassName 注解类名
     * @return 是否存在标注
     */
    private boolean isAnnotationPresent(Element element, String annotationClassName) {
        return element.getAnnotationMirrors() // 返回当前元素所有的注解集合
                .stream().anyMatch(annotation -> Objects.equals(annotationClassName, annotation.getAnnotationType().toString()));
    }

    /*@Override
    public SourceVersion getSupportedAnnotationTypes() {
        //return super.getSupportedAnnotationTypes();
        return SourceVersion.latest();
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return super.getSupportedSourceVersion();
    }*/
}
