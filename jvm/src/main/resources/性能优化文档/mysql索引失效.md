### mysql 索引 对应的数据结构

![索引的数据结构](images/索引使用的数据结构.png)

[二叉树数据结构](https://zhuanlan.zhihu.com/p/27700617)

### 索引介绍

B+Tree 索引和 Hash 索引是比较常用的两个索引数据存储结构，B+Tree 索引是通过B+ 树实现的，是有序排列存储，所以在排序和范围查找方面都比较有优势。

Hash 索引相对简单些，只有 Memory 存储引擎支持 Hash 索引，Hash 索引适合 key-value 键值对查询，无论表数据多大，查询数据的复杂度都是 O(1)，且直接通过 Hash 索引查询的性能比其它索引都要优越。

在创建表时，无论使用 InnoDB 还是 MyISAM 存储引擎，默认都会创建一个主键索引，而创建的主键索引默认使用的是 B+Tree 索引，不过虽然这两个存储引擎都支持 B+Tree 索引，但它们在具体的数据存储结构方面却有所不同，InnoDB 默认创建的主键索引是聚族索引（Clustered Index），其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚族索引。

```sql
CREATE TABLE `merchandise` (  
`id` int(11) NOT NULL,  
`serial_no` varchar(20)  DEFAULT NULL,  
`name` varchar(255) DEFAULT NULL,  
`unit_price` decimal(10, 2) DEFAULT NULL,  
PRIMARY KEY (`id`) USING BTREE
) CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

INSERT INTO `test`.`merchandise`(`id`, `serial_no`, `name`, `unit_price`) VALUES (1, '000231', '商品001', 1000.00);
INSERT INTO `test`.`merchandise`(`id`, `serial_no`, `name`, `unit_price`) VALUES (2, '000262', '商品002', 92.00);
INSERT INTO `test`.`merchandise`(`id`, `serial_no`, `name`, `unit_price`) VALUES (3, '000321', '商品003', 321.00);
INSERT INTO `test`.`merchandise`(`id`, `serial_no`, `name`, `unit_price`) VALUES (4, '000339', '商品004', 10.00);
INSERT INTO `test`.`merchandise`(`id`, `serial_no`, `name`, `unit_price`) VALUES (5, '000413', '商品005', 71.00);
```

### 覆盖索引优化查询

假设只需要查询商品的名称、价格信息，有什么方式来避免回表呢？可以建立一个组合索引，即商品编码、名称、价格作为一个组合索引，如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。

从辅助索引中查询得到记录，而不需要通过聚族索引查询获得，MySQL 中将其称为覆盖索引，使用覆盖索引的好处很明显，不需要查询出包含整行记录的所有信息，因此可以减少大量的 I/O 操作。

通常在 InnoDB 中，除了查询部分字段可以使用覆盖索引来优化查询性能之外，统计数量也会用到。例如，在 SELECT COUNT(*) 时，如果不存在辅助索引，此时会通过查询聚族索引来统计行数，如果此时正好存在一个辅助索引，则会通过查询辅助索引来统计行数，减少 I/O 操作。

### 自增字段作主键优化查询

InnoDB 创建主键索引默认为聚族索引，数据被存放在了 B+ 树的叶子节点上，也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。

使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面，因为不需要重新移动数据，因此这种插入数据的方法效率非常高。

使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。
 
### 前缀索引优化

前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引。

索引文件是存储在磁盘中的，而磁盘中最小分配单元是页，通常一个页的默认大小为 16KB，假设建立的索引的每个索引值大小为 2KB，则在一个页中，我们能记录 8个索引值，假设我们有 8000 行记录，则需要 1000 个页来存储索引，如果使用该索引查询数据，可能需要遍历大量页，这显然会降低查询效率。

减小索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度，在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

前缀索引是有一定的局限性的，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。

### 防止索引失效

对于 Hash 索引实现的列，如果使用到范围查询，那么该索引将无法被优化器使用到。也就是说 Memory 引擎实现的 Hash 索引只有在“=”的查询条件下，索引才会生效。

以 % 开头的 LIKE 查询将无法利用节点查询数据。

使用复合索引时，需要使用索引中的最左边的列进行查询，才能使用到复合索引。例如在 order 表中建立一个复合索引 idx_user_order_status(order_no, status, user_id)，如果使用 order_no、order_no+status、order_no+status+user_id 以及order_no+user_id 组合查询，则能利用到索引；而如果我们用 status、status+user_id查询，将无法使用到索引，这也是经常听过的最左匹配原则。

如果查询条件中使用 or，且 or 的前后条件中有一个列没有索引，那么涉及的索引都不会被使用到。

对索引进行函数操作或者表达式计算也会导致索引的失效。

在一些特定情况下，没有使用辅助索引，可以利用force index 强制使用某类辅助索引。




















