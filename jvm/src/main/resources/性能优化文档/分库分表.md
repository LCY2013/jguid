### 分库分表存在的问题

#### 1. 分布式事务问题
在提交订单时，除了创建订单之外，还需要扣除相应的库存。而订单表和库存表由于垂直分库，位于不同的库中，这时需要通过分布式事务来保证提交订单时的事务完整性。

通常，解决分布式事务有两种通用的方式：两阶事务提交（2PC）以及补偿事务提交（TCC）。

通常有一些中间件已经帮我们封装好了这两种方式的实现，例如 Spring 实现的 JTA，目前阿里开源的分布式事务中间件 Seata(Fescar)，就很好地实现了与 Dubbo 的兼容。

#### 2. 跨节点 JOIN 查询问题
用户在查询订单时，往往需要通过表连接获取到商品信息，而商品信息表可能在另外一个库中，这就涉及到了跨库 JOIN 查询。

通常，会冗余表或冗余字段来优化跨库 JOIN 查询。对于一些基础表，例如商品信息表，可以在每一个订单分库中复制一张基础表，避免跨库 JOIN 查询。而对于一两个字段的查询，也可以将少量字段冗余在表中，从而避免 JOIN 查询，也就避免了跨库JOIN 查询。

#### 3. 跨节点分页查询问题
当用户在订单列表中查询所有订单时，可以通过用户 ID 的 Hash 值来快速查询到订单信息，而运营人员在后台对订单表进行查询时，则是通过订单付款时间来进行查询的，这些数据都分布在不同的库以及表中，此时就存在一个跨节点分页查询的问题了。

通常一些中间件是通过在每个表中先查询出一定的数据，然后在缓存中排序后，获取到对应的分页数据。这种方式在越往后面的查询，就越消耗性能。

通常建议使用两套数据来解决跨节点分页查询问题，一套是基于分库分表的用户单条或多条查询数据，一套则是基于 Elasticsearch、Solr 存储的订单数据，主要用于运营人员根据其它字段进行分页查询。为了不影响提交订单的业务性能，一般使用异步消息来实现Elasticsearch、Solr 订单数据的新增和修改。

#### 4. 全局主键 ID 问题
在分库分表后，主键将无法使用自增长来实现了，在不同的表中需要统一全局主键ID。因此，需要单独设计全局主键，避免不同表和库中的主键重复问题。

使用 UUID 实现全局 ID 是最方便快捷的方式，即随机生成一个 32 位 16 进制数字，这种方式可以保证一个 UUID 的唯一性，水平扩展能力以及性能都比较高。但使用 UUID 最大的缺陷就是，它是一个比较长的字符串，连续性差，如果作为主键使用，性能相对来说会比较差。

也可以基于 Redis 分布式锁实现一个递增的主键 ID，这种方式可以保证主键是一个整数且有一定的连续性，但分布式锁存在一定的性能消耗。

还可以基于 Twitter 开源的分布式 ID 生产算法——snowflake 解决全局主键 ID 问题，snowflake 是通过分别截取时间、机器标识、顺序计数的位数组成一个 long 类型的主键 ID。这种算法可以满足每秒上万个全局 ID 生成，不仅性能好，而且低延时。

#### 5. 扩容问题
随着用户的订单量增加，根据用户 ID Hash 取模的分表中，数据量也在逐渐累积。此时，需要考虑动态增加表，一旦动态增加表了，就会涉及到数据迁移问题。

在最开始设计表数据量时，尽量使用 2 的倍数来设置表数量。当需要扩容时，也同样按照 2 的倍数来扩容，这种方式可以减少数据的迁移量。









